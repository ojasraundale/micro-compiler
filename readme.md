# MICRO Compiler

This Repo implements a parser with symbol table and also produces the machine code in tiny language for the MICRO programming language. 
The machine code can be run by the tiny simulator. 

## Scope

Statements, Expressions and Functions are implemented currently. Program flow constructs (Conditions and Loops) still remain to be implemented though. Sample input codes and arguments can be found in [input](/input). The output generated codes and outputs can also be found in [output](/output)


## Build the Compiler

To build the compiler first install flex and bison. You can use the following commands for Ubuntu:

``sudo apt-get install flex``

``sudo apt-get install bison``

Then clone this repository and run the following command from inside the directory

## Usage:

``make compiler`` 						: 	Builds the compiler

``./a.out <path_of_input_file>``		:	Prints assembly code on the terminal

``./a.out <input_file> > <output_file>`` 

(OR)

``./runme <input_file> <output_file>``	:	Redirects the output(assembly code in tiny) to the <output_file>

``make clean``							: 	Removes all the files produced by "make compiler"

``make team`` 							: 	Prints out the team details

To test the machine code
g++ tinyNew.C -o tiny (Build the simulator) (No need to build if already ``make compiler`` has been called)

``./tiny <input_assembly_code(output_file of compiler)>``


## Understanding the Code

The Code comprises of the following: 

1.) Lexical analyser: This is written in flex and bison [scanner.l](/scanner.l). The code is converted to sequence into tokens which is then fed to the parser.

2.) Parser: This is written in bison [microParser.y](/microParser.y). The input code is parsed. A context free grammar is defined for this language and any valid piece of code can be generated using the grammar.

3.) Code Generation: Code Generation is divided into two parts. First Three Address Code in generated which is then converted into assembly level code. This code can be found in [classes](/classes). This step involves building the symbol table and generating the Abstract Syntax Tree. An intermediate three address code is generated by performing post-order traversal of the AST. Then the intermediate code in converted to assembly code.


## About 

This project was part of the Course CS460: Compilers in the Spring 2020 Semester. 

